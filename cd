import groovy.json.*
import groovy.yaml.*

def deployECS = "${p:CF-Validate-Parameters/ecs.enforceTwistlock}"

if ((deployECS != null && deployECS == "true")  ){
	println "Perform getParameters. deployECR=" + deployECS
} else {
	//println "Skip getParameters. deployECR=" + deployECS
	//System.exit(0)
}

//UCD parameters
def parametersFileName = "${p:environment/cf.parametersJson}"
def cfTemplateFileName = "${p:environment/cf.cloudformationTemplate}"
def artifactory = "${p?:environment/app.artifactory}"
def replaceInUCD = "${p?:replaceInUCD}"
def componentVersion = "${p:version.name}" //used only if replaceInUCD is set to true
def sharedServicesReposString = '''${p?:sharedEcrRepos}'''

//Make sure parameters file exists
def parametersFile = new File(parametersFileName)

if (!parametersFile.exists()) {
    println "Failed to locate ${parametersFileName}"
    System.exit(1)
}

//make sure cf template file exists
def cfTemplateFile = new File(cfTemplateFileName)

if (!cfTemplateFile.exists()) {
    println "Failed to locate ${cfTemplateFileName}"
    System.exit(1)
}

//Extract all the parameters from parameters file into ucd properties
//Also update container image version to component version if it does not match
def parameters
try {
    parameters = new JsonSlurper().parseText(parametersFile.getText())   
} catch(Exception e) {
    println "Failed to parse parameters json file: " + parametersFile.name
    System.exit(1)
}
def containerImages = (deployECS == "true") ? getContainerImages(cfTemplateFile) : []
def parameterList = ["ApplicationShortName", "ContainerName", "ClusterName", "ServiceName", "MeshName"] + containerImages
def updatedJson = false
def errors = []
def targetImages = [:]

parameters.each { parameter ->
    key = parameter.ParameterKey
    value = parameter.ParameterValue
    
    if (parameterList.contains(key)) {
        println "Getting parameter: ${key}"
        
        //perform steps for container image parametesr
        if (containerImages.contains(key)) {
            def (ecrPath, imageVersion) = value.split(":")
            println "current image version: ${imageVersion}"
            
            //replace image tag with ucd component version when "replaceInUCD", set to true
            if (replaceInUCD == "true") {
                if (imageVersion != componentVersion) {
                    println "Changing ${imageVersion} to ${componentVersion} in json file"
                    value = ecrPath + ":" + componentVersion
                    parameter["ParameterValue"] = value
                    updatedJson = true
                    imageVersion = componentVersion
                }
            }
            
            //always make sure there is no latest tag
            if (imageVersion == "latest") {
                errors << "${key} contains latest as version. It needs to be a specific version for images"
            }
            
            //add to map of target images (this will include all images including base images. we'll skip pushing base images to ecr but perform verification on all)
            targetImages.put(key, value)
        }
        
        println "${key} : ${value}"
        outProps.put(key, value)
    }
}

if (errors.size() > 0) {
    println "Failed with the following errors:\n" + errors.join("\n")
    System.exit(1)
}

if (deployECS != "true") {
    println "finished getting parameters for non ecs cf scenario"
    System.exit(0)
}

if (updatedJson) {
    def updateParametersJson = new JsonBuilder(parameters).toPrettyString()
    println updateParametersJson
    parametersFile.write(updateParametersJson)
}

//figure out source images for pushing images to ecr. Two cases: either from dev ecr or from artifactory
def sourceImages
if (artifactory == "" || artifactory == "false") {
    //get ecr paths from dev json
    def sourceEnvJson
    if ("${p:environment/envType}" != "DEVL" ) {
        println "We'll need to promote the image to this env's ECR repo so need info on prior env"
        def (priorEnvRole, priorEnvAccountId, priorEnvType, priorEnvJson, priorEnvRegion) = getPriorEnvInfo()
        
        println "Getting priorEnvRole: " + priorEnvRole
        println "Getting priorEnvAccountId: " + priorEnvAccountId
        println "Getting priorEnvType: " + priorEnvType
        println "Getting priorEnvRegion: " + priorEnvRegion
        
        outProps.put("priorEnvRole", priorEnvRole)
        outProps.put("priorEnvAccountId", priorEnvAccountId)
        outProps.put("priorEnvType", priorEnvType)
        outProps.put("priorEnvRegion", priorEnvRegion)
        
        sourceEnvJson = priorEnvJson
    } else {
        sourceEnvJson = parametersFileName
    }
    
    //create a file with list of ecr locations for container images that we need to promote: <sourceImage>,<targetImage>
    sourceImages = getSourceImagesFromECR(sourceEnvJson, containerImages, replaceInUCD, componentVersion)
} else if (artifactory == "true") {
    //in the artifactory case we need to ensure that tags accross all jsons match (since pulling from artifactory could compromise consistency of component version)
    //perhaps have a new file for tags that is configured in component and then can check all tags in json against that one
    
    //get from artifactory
    def repoMappingsString = '''${p?:environment/ecr.repoMappings}'''
    def artifactoryUrl = "${p?:system/ARTIFACTORY_URL}"
    sourceImages = [:]
    
    //need to parse repoMappings into map
    def repoMappings = getRepoMappings(repoMappingsString) 
    
    targetImages.each { image ->
        def key = image.key
        def (ecrPath, tag) = image.value.split(":")
        def ecrRepo = ecrPath.split("/")[1] + "/" +  ecrPath.split("/")[2]
        def artifactoryImage
        
        if (repoMappings.containsKey(ecrRepo)) {
            def artifactoryRepo = repoMappings[ecrRepo]
            artifactoryImage = artifactoryUrl + "/" + artifactoryRepo + ":" + tag
        } else {
            artifactoryImage = ""
        }
         
        
        sourceImages.put(key, artifactoryImage)
        
    }
    
    //check to make sure that all containerImages which aren't shared services repos have a source image in artifactory
    def sharedServicesRepos = sharedServicesReposString.split("\n")
    errors = []
    
    targetImages.each { image ->
        def ecrRepo = image.value
        if ((sourceImages[image.key] == "") && (!isSharedServicesRepo(ecrRepo, sharedServicesRepos))) {
            errors << "${ecrRepo} is missing a source repo in artifactory in ecr.repoMappings property"
        }
    }
    
    if (errors) {
        println "Failed while validating ecr.repoMappings:\n" + errors.join("\n")
        System.exit(1)
    }
}

def containerImagesFile = writeImagesToFile(sourceImages, targetImages)
println "Getting containerImagesFile: " + containerImagesFile
outProps.put("containerImagesFile", containerImagesFile)

def isSharedServicesRepo(def ecrImage, def sharedServicesRepos) {
    def isSSRepo = false
    sharedServicesRepos.each { ssRepo ->
        if (ecrImage.contains(ssRepo)) {
            isSSRepo = true
        }
    }
    
    return isSSRepo
}

def getContainerImages(def cfTemplateFile) {
    println "Parsing yaml file"
    def cfTemplate
    try {
        cfTemplate = new YamlSlurper().parseText(cfTemplateFile.getText().replaceAll("!Ref", "-Ref"))
    } catch (Exception e) {
        println "Failed to parse yaml file" + cfTemplate.name
        System.exit(1)
    }
    println "Parsed cloudformation yaml"
    
    def containerImages = []
    getNode(cfTemplate, "Resources").TaskDefinition.Properties.ContainerDefinitions.each { containerDef ->
        def imageParam = containerDef.Image
        imageParam = imageParam.replaceAll("-Ref ", "")
        println "found image in cf template: ${imageParam}"
        containerImages << imageParam
    }
    
    return containerImages
}

def getNode(def tree, def name) {
    def requestedElement 
    tree.each { node ->
        if (node.key == name) {
            requestedElement = node.value  
        }
    }
    
    return requestedElement
}

def getSourceImagesFromECR(def envJson, def containerImages, def replaceInUCD, def componentVersion) {
    println "Going to check parameters json file from previousEnvInfo: ${envJson}"
    def parametersFile = new File(envJson)
    def imageLocations = [:]
    
    if (!parametersFile.exists()) {
        println "Failed to locate ${envJson}"
        System.exit(1)
    }
    
    def parameters
    try {
        parameters = new JsonSlurper().parseText(parametersFile.getText())    
    } catch(Exception e) {
        println "Failed to parse parameters json file: " + parametersFile.name
        System.exit(1)
    }
    
    parameters.each { parameter ->
        if (containerImages.contains(parameter.ParameterKey)) {
            def value = parameter.ParameterValue
            
            if (replaceInUCD == "true") {
                def (ecrPath, imageVersion) = value.split(":")
                
                if (imageVersion != componentVersion) {
                    value = ecrPath + ":" + componentVersion
                }
            }
            
            imageLocations.put(parameter.ParameterKey, value)
        }
    }
    
    return imageLocations   
}

def getRepoMappings(def repoMappingsString) {
    def repoMappings = [:]
    def errors = []
    
    repoMappingsString.split("\n").each { line ->
        def values = line.split(":")
        
        if (values.size() != 2) {
            errors << "${line} is invalid needs to include: <artifactory>:<ecrRepo>"
        }
        
        def artifactoryRepo = values[0]
        def ecrRepo = values[1]
        
        repoMappings.put(ecrRepo, artifactoryRepo)
    }
    
    if (errors) {
        println "Failed while validating ecr.repoMappings:\n" + errors.join("\n")
        System.exit(1)
    }
    
    return repoMappings
}

def writeImagesToFile(def sourceImages, def targetImages) {
    println "Going to create a list of ecr locations for promoting images"
    def imagesFileName = "images.txt"
    def imagesFile = new File(imagesFileName)
    def images = ""
    def errors = []
    
    if (sourceImages.size() != targetImages.size()) {
        println "Source images and target images need be the same amount"
        System.exit(1)
    }
    
    targetImages.each { image ->
        def parameter = image.key
        if (!sourceImages.containsKey(parameter)) {
            errors << "lower env json and current env json don't match for parameter: " + parameter
        } else {
            def line = sourceImages[parameter] + "," + image.value + "\n"
            images = images.concat(line)   
        }
    }
    
    if (errors) {
        println "Failed with the following errors:\n" + errors.join("\n")
        System.exit(1)
    }
    
    imagesFile.write(images)
    
    return imagesFileName
}

def getPriorEnvInfo() {
    def errors = []
    def priorEnvInfoString = '''${p:environment/ecr.previousEnvInfo}'''
    def priorEnvInfo = [:]
    
    println "Validating previousEnvInfo"
    priorEnvInfoString.split("\n").each { line ->
        def values = line.split("=")
        if (values.size() != 2) {
            errors << "${line} is invalid. Needs to be in this format: <property>=<value>"
        }
        
        priorEnvInfo.put(values[0], values[1])
    }
    
    if (errors) {
        println "Failed while validating previousEnvInfo:\n" + errors.join("\n")
        System.exit(1)
    }
    
    if (!priorEnvInfo.containsKey("aws.region")) {
        priorEnvInfo.put("aws.region", "us-east-1")
    }
    
    def requiredFields = ["iam.awsRole", "iam.awsAccountId", "cf.parametersJson", "envType", "aws.region"]
    
    requiredFields.each { field ->
        if (!priorEnvInfo.containsKey(field)) {
            errors << "Missing ${field} in previousEnvInfo"
        }
    }
    
    if (errors) {
        println "Failed while validating previousEnvInfo:\n" + errors.join("\n")
        println "Should have the following:\n------------------------------------------"
        println "awsRole=<role>\nawsLifeCycle=<accountId>\nenvType=<envType>\nparametersJson=<relativePathToJson>"
        System.exit(1)
    }

    return [priorEnvInfo["iam.awsRole"], priorEnvInfo["iam.awsAccountId"], priorEnvInfo["envType"], priorEnvInfo["cf.parametersJson"], priorEnvInfo["aws.region"]]
}
